# 소프트웨어 공학

## 소프트웨 품질의 정의
소프트웨어 기능 상의 품질과 구조 상의 품질 두 개의 구별된 개념을 가리킨다

소프트웨어 기능 상의 품질 : 기능 요건이나 사양에 기반하여 주어진 설계를 얼마나 잘 충족하고 있는지를 반영하는 품질 정의
소프트웨어 목적에 부합하는지ㅣ 시장의 경쟁작과 

functional requirements
-> 

소프트웨어 구조 상의 품질을 정의할 때 어떤게 중요한가?

* **소프트웨어 테스트 & 소프트웨어 구조 원칙*** 

---

### 소프트웨어 품질의 정의 역사
기능적인 품질요소나 구조상의 품질요소인지에 따라 기준이 내려지고 있음

---
## 소프트웨어 품질의 중요성
소프트웨어 품질 요소는 매우 다양
모든 요소를 만족시키지 못하기 때문에 소프트웨어 특성을 고려한 적절한 품질 목표 설정이 중요

---
## 소프트웨어 스테이크홀더
특정 대상 및 주제아ㅗ 관련하여 직.간접적으로 이해관계를 가지는 사람을 가리킴

소프트웨어에서의 이해관계자는 회사의 내.외부에서 소프트웨어 프로저ㅔㄱ트의 결정, 활동 또는 결과에 영향을 미치거나 영향을 받을 수 있는 사람들에 해당됨

항상 그 기준이 다름

각 구성요소들이 스테이크홀더로 표현될 수 있음
![](https://i.imgur.com/kKL0Pb2.png)

이것들을 외우기 보다는 어떤 주체가 어떤 기대치를 가짐으로써 어떤 품질 요소를 요구하는지 확인

---
## 소프트웨어 외적 품질 요소

정확성
	주어진 명세서의 내용을 하나씩 테스트하여 원하는 결과를 생성하는지 여부로 판단
	Correctness(P) = (A/B) (테스트를 통해 명세 내용대로 동작하지 않은 기능 수 / 전체 요구사항 개수)

신뢰성(Reliability)
	소프트웨어를 사용하는 동안 나타난 오류(고장) 발생 빈도로 판단
	소프트웨어 고장의 빈도수와 치명도로 나타냄 
	ex) MTBF(Mean Time Between Failure) = 10,000H

**견고성(Robustness)**
	사용자가 제시한 요구사항 명세에 정의하지 않은 조건이나 환경에서도 소프트웨어가 합리적으로 동작해야함
	항공기 제어 소프트웨어, 원자력 제어 소프트웨어 등 위험한 임무를 수행해야 하는 시스템에서 특히 중요
	QA팀

성능(Performance)
	소프트웨어 효율성(Effciency)을 의미
	소프트웨어를 수행하기 위해 필요한 메모리의 양(Byte), 총 실행 시간(msec) 등이 척도가 됨

가용성(Availability)
	서버, 네트워크, 프로그램 등의 정보 시스템이 정상적으로 사용 가능한 정도
	소프트웨어 사용 가능시간 / 소프트웨어 전체 운영 시간 나눈값이 클 수록 가용성이 높아짐 
	

보안성(Security)
	외부의 악의적인 공격자의 위협을 소프트웨어가 막아낼 수 있도록 구현하여 잠재적 공격이 예측되는 상황에서도 소프트웨어가 올바르게 동작
	취약점 개수, 사고 통계, 보안 취약으로 인한 연간 손실액 등이 척도가 됨
	-> 보안성의 척도

---
## 소프트웨어 내적 품질 요소
검증 가능성
	소프트웨어가 지닌 속성이 올바르다는 것을 안전하게 확인 가능
	 ㅁ
	 검증 가능성의 평가 수다능ㄴ 정형 검증과 테스트로 나누어짐

소프트웨어 테스트만으로는 한계가 존재했기 때문에 나옴
견고성과 연관되어 나오게 된 내용

재사용성
새로운 소프트웨어를 개발하기 위해 기존 소프트웨어 컴포넌트를 사용하는 정도

이식성
얼마나 다양한 하드웨어 플랫폼을 지원하는가 + 얼마나 다양한 버전의 소프트웨어 플랫폼을 지원

생산성
외적 품질 요소인 성능의 속성을 적용한 내적 품질 속성

---
## 소프트웨어 품질 모델
McCall의 FCM 모델

HP의 FURPS 모델
-> 구형 표준을 기반으로 만든 모델
-> 이런게 있다 정도만 짚고 넘어가기

ISO/IEC 25010(2011)
-> 기존 ISO 9126 모델이 존재하였으나, ISO 25010 모델로 통폐합됨

---
프로그래밍 언어
컴퓨터 프로그램을 작성하기 위한 표시법 시스템
문법에 따라서 프로그램의 논리적 동작을 작성
프로그래밍 언어에 따라 논리적 동작을 실제 컴퓨터의 동작으로 변환

고급 프로그래밍 언어
인간의 자연어에 가깝게 만들어진 언어
ex) C, C++, Go, Java

저급 프로그래밍 언어
컴퓨터가 직접 이해하고 실행할 수 있는 언어, 이진수 표현이거나 그것에 대응

기계어
이진수로 표현되는 명령어, 가독성을 위해 Hex Code로 표현됨
숫자로 기계의 동작을 포현하므로 직관적으로 이해 어려움

어셈블리어
0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어
기계어와 1대1로 대응

기계어와 어셈블리어는 ISA에 의해 결정

## 고급 언어의 종류
컴파일 언어
한 번에 컴파일

인터프리터 언어
소스 코드가 한 줄씩 실행

Jit 컴파일 방식
-> 

---
## ISA (Instruction Set Architecture)

명령어 집합

ISA에서 정의하는 것
* CPU가 이해할 수 있는 명령어 모음
* 명령어 형식
* 레지스터
* 메모리 주소 지정 모드
* 데이터 타입

---
## ISA vs Microarchitecture

ISA는 하드웨어와 소프트웨어 사이의 인터페이스를 구현하는 방법을 정의함

Microarchitecture는 ISA를 구현하는 구체적인 하드웨어 설계 의미
-> 명령어 파이프라이닝

---
## ISA
CISC (Complex Instruction Set Computer) -> 가변 길이 형태의 명령어를 사용
특징
* x86, x86-64가 대표적
* 다양한 형태의 명령어와 가변 길이 명령어 사용
* 

Instruction 예시 들어서 설명하면 좋음

RISC
1클럭 내외로 실행되는 명령어 지향 -> 명령어 파이프라이닝에 최적화
레지스터 적극적 활용
ARM, MIPS, RISC-V 등

실질적으로 이 명령어는 몇 클럭을 돌고 어떤 명령어는 몇 클럭을 도는지 확인하는 것이 CISC
RISC는 하나 실행시 1클럭

---
## MIPS
Vonn Neumann Computer
메모리에 프로그램을 업로드하여 CPU에서 명령어를 순차적으로 처리하는 방식

![](https://i.imgur.com/70jxDj2.png)


MIPS
RISC 계열의 명령어, 32 비트 고정 길이의 명령어를 사용
	명령어 형식이 고정되어, 명령어 처리를 위한 Microarchitecture의 구조가 간단함

R-type
![](https://i.imgur.com/4bUo573.png)


I-type
![](https://i.imgur.com/Ldyq27Z.png)

J-type
![](https://i.imgur.com/jGrL7z0.png)

Immediate Addressing
![](https://i.imgur.com/UaahjxS.png)
명령어에 피연산자로 사용할 값이 포함되는 경우

Register Addressing
![](https://i.imgur.com/I2S3LPp.png)
RS, RT에 명시된 레지스터를 피연산자로 사용

Base Addressing
![](https://i.imgur.com/cy3nKmz.png)
레지스터에 있는 값을 기준 주소로 삼아 Offset을 더하여 주소를 구하고, 메모리에 접근하는 방식

PC-relative Addressing
![](https://i.imgur.com/Ita1k88.png)
현재 명령어의 주소에 오프셋을 더해 유효 주소를 계산

Pseudo direct addressing
![](https://i.imgur.com/0mtK6Hj.png)
상위 비트는 현재 PC에서 가져오고, 하위 26비트는 명령어에서 가져와서 유효 주소를 계산

